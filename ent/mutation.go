// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/iwanhae/Jupynetes/ent/event"
	"github.com/iwanhae/Jupynetes/ent/predicate"
	"github.com/iwanhae/Jupynetes/ent/server"
	"github.com/iwanhae/Jupynetes/ent/template"
	"github.com/iwanhae/Jupynetes/ent/user"
	"github.com/iwanhae/Jupynetes/pkg/common"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEvent    = "Event"
	TypeServer   = "Server"
	TypeTemplate = "Template"
	TypeUser     = "User"
)

// EventMutation represents an operation that mutate the Events
// nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	message       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	server        map[int]struct{}
	removedserver map[int]struct{}
	clearedserver bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows to manage the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for Event.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the id field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMessage sets the message field.
func (m *EventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the message value in the mutation.
func (m *EventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old message value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage reset all changes of the "message" field.
func (m *EventMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the created_at field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserIDs adds the user edge to User by ids.
func (m *EventMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *EventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *EventMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *EventMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *EventMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *EventMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *EventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddServerIDs adds the server edge to Server by ids.
func (m *EventMutation) AddServerIDs(ids ...int) {
	if m.server == nil {
		m.server = make(map[int]struct{})
	}
	for i := range ids {
		m.server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the server edge to Server.
func (m *EventMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared returns if the edge server was cleared.
func (m *EventMutation) ServerCleared() bool {
	return m.clearedserver
}

// RemoveServerIDs removes the server edge to Server by ids.
func (m *EventMutation) RemoveServerIDs(ids ...int) {
	if m.removedserver == nil {
		m.removedserver = make(map[int]struct{})
	}
	for i := range ids {
		m.removedserver[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed ids of server.
func (m *EventMutation) RemovedServerIDs() (ids []int) {
	for id := range m.removedserver {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the server ids in the mutation.
func (m *EventMutation) ServerIDs() (ids []int) {
	for id := range m.server {
		ids = append(ids, id)
	}
	return
}

// ResetServer reset all changes of the "server" edge.
func (m *EventMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
	m.removedserver = nil
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.message != nil {
		fields = append(fields, event.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldMessage:
		return m.Message()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldMessage:
		return m.OldMessage(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldMessage:
		m.ResetMessage()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.server != nil {
		edges = append(edges, event.EdgeServer)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeServer:
		ids := make([]ent.Value, 0, len(m.server))
		for id := range m.server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.removedserver != nil {
		edges = append(edges, event.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removedserver))
		for id := range m.removedserver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, event.EdgeUser)
	}
	if m.clearedserver {
		edges = append(edges, event.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeUser:
		return m.cleareduser
	case event.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeUser:
		m.ResetUser()
		return nil
	case event.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// ServerMutation represents an operation that mutate the Servers
// nodes in the graph.
type ServerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	template             *string
	variables            **common.TemplateVariables
	ip                   *string
	description          *string
	cpu                  *int
	addcpu               *int
	memory               *int
	addmemory            *int
	nvidia_gpu           *int
	addnvidia_gpu        *int
	created_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	owners               map[int]struct{}
	removedowners        map[int]struct{}
	clearedowners        bool
	event                map[int]struct{}
	removedevent         map[int]struct{}
	clearedevent         bool
	template_from        map[int]struct{}
	removedtemplate_from map[int]struct{}
	clearedtemplate_from bool
	done                 bool
	oldValue             func(context.Context) (*Server, error)
	predicates           []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows to manage the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for Server.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the id field of the mutation.
func withServerID(id int) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServerMutation) ResetName() {
	m.name = nil
}

// SetTemplate sets the template field.
func (m *ServerMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the template value in the mutation.
func (m *ServerMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old template value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate reset all changes of the "template" field.
func (m *ServerMutation) ResetTemplate() {
	m.template = nil
}

// SetVariables sets the variables field.
func (m *ServerMutation) SetVariables(cv *common.TemplateVariables) {
	m.variables = &cv
}

// Variables returns the variables value in the mutation.
func (m *ServerMutation) Variables() (r *common.TemplateVariables, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old variables value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldVariables(ctx context.Context) (v *common.TemplateVariables, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVariables is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables reset all changes of the "variables" field.
func (m *ServerMutation) ResetVariables() {
	m.variables = nil
}

// SetIP sets the ip field.
func (m *ServerMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the ip value in the mutation.
func (m *ServerMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old ip value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP reset all changes of the "ip" field.
func (m *ServerMutation) ResetIP() {
	m.ip = nil
}

// SetDescription sets the description field.
func (m *ServerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ServerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription reset all changes of the "description" field.
func (m *ServerMutation) ResetDescription() {
	m.description = nil
}

// SetCPU sets the cpu field.
func (m *ServerMutation) SetCPU(i int) {
	m.cpu = &i
	m.addcpu = nil
}

// CPU returns the cpu value in the mutation.
func (m *ServerMutation) CPU() (r int, exists bool) {
	v := m.cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old cpu value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCPU is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// AddCPU adds i to cpu.
func (m *ServerMutation) AddCPU(i int) {
	if m.addcpu != nil {
		*m.addcpu += i
	} else {
		m.addcpu = &i
	}
}

// AddedCPU returns the value that was added to the cpu field in this mutation.
func (m *ServerMutation) AddedCPU() (r int, exists bool) {
	v := m.addcpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPU reset all changes of the "cpu" field.
func (m *ServerMutation) ResetCPU() {
	m.cpu = nil
	m.addcpu = nil
}

// SetMemory sets the memory field.
func (m *ServerMutation) SetMemory(i int) {
	m.memory = &i
	m.addmemory = nil
}

// Memory returns the memory value in the mutation.
func (m *ServerMutation) Memory() (r int, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old memory value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds i to memory.
func (m *ServerMutation) AddMemory(i int) {
	if m.addmemory != nil {
		*m.addmemory += i
	} else {
		m.addmemory = &i
	}
}

// AddedMemory returns the value that was added to the memory field in this mutation.
func (m *ServerMutation) AddedMemory() (r int, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemory reset all changes of the "memory" field.
func (m *ServerMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
}

// SetNvidiaGpu sets the nvidia_gpu field.
func (m *ServerMutation) SetNvidiaGpu(i int) {
	m.nvidia_gpu = &i
	m.addnvidia_gpu = nil
}

// NvidiaGpu returns the nvidia_gpu value in the mutation.
func (m *ServerMutation) NvidiaGpu() (r int, exists bool) {
	v := m.nvidia_gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldNvidiaGpu returns the old nvidia_gpu value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldNvidiaGpu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNvidiaGpu is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNvidiaGpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNvidiaGpu: %w", err)
	}
	return oldValue.NvidiaGpu, nil
}

// AddNvidiaGpu adds i to nvidia_gpu.
func (m *ServerMutation) AddNvidiaGpu(i int) {
	if m.addnvidia_gpu != nil {
		*m.addnvidia_gpu += i
	} else {
		m.addnvidia_gpu = &i
	}
}

// AddedNvidiaGpu returns the value that was added to the nvidia_gpu field in this mutation.
func (m *ServerMutation) AddedNvidiaGpu() (r int, exists bool) {
	v := m.addnvidia_gpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetNvidiaGpu reset all changes of the "nvidia_gpu" field.
func (m *ServerMutation) ResetNvidiaGpu() {
	m.nvidia_gpu = nil
	m.addnvidia_gpu = nil
}

// SetCreatedAt sets the created_at field.
func (m *ServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *ServerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *ServerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *ServerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[server.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *ServerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[server.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *ServerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, server.FieldDeletedAt)
}

// AddOwnerIDs adds the owners edge to User by ids.
func (m *ServerMutation) AddOwnerIDs(ids ...int) {
	if m.owners == nil {
		m.owners = make(map[int]struct{})
	}
	for i := range ids {
		m.owners[ids[i]] = struct{}{}
	}
}

// ClearOwners clears the owners edge to User.
func (m *ServerMutation) ClearOwners() {
	m.clearedowners = true
}

// OwnersCleared returns if the edge owners was cleared.
func (m *ServerMutation) OwnersCleared() bool {
	return m.clearedowners
}

// RemoveOwnerIDs removes the owners edge to User by ids.
func (m *ServerMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowners == nil {
		m.removedowners = make(map[int]struct{})
	}
	for i := range ids {
		m.removedowners[ids[i]] = struct{}{}
	}
}

// RemovedOwners returns the removed ids of owners.
func (m *ServerMutation) RemovedOwnersIDs() (ids []int) {
	for id := range m.removedowners {
		ids = append(ids, id)
	}
	return
}

// OwnersIDs returns the owners ids in the mutation.
func (m *ServerMutation) OwnersIDs() (ids []int) {
	for id := range m.owners {
		ids = append(ids, id)
	}
	return
}

// ResetOwners reset all changes of the "owners" edge.
func (m *ServerMutation) ResetOwners() {
	m.owners = nil
	m.clearedowners = false
	m.removedowners = nil
}

// AddEventIDs adds the event edge to Event by ids.
func (m *ServerMutation) AddEventIDs(ids ...int) {
	if m.event == nil {
		m.event = make(map[int]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the event edge to Event.
func (m *ServerMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared returns if the edge event was cleared.
func (m *ServerMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the event edge to Event by ids.
func (m *ServerMutation) RemoveEventIDs(ids ...int) {
	if m.removedevent == nil {
		m.removedevent = make(map[int]struct{})
	}
	for i := range ids {
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed ids of event.
func (m *ServerMutation) RemovedEventIDs() (ids []int) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the event ids in the mutation.
func (m *ServerMutation) EventIDs() (ids []int) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent reset all changes of the "event" edge.
func (m *ServerMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// AddTemplateFromIDs adds the template_from edge to Template by ids.
func (m *ServerMutation) AddTemplateFromIDs(ids ...int) {
	if m.template_from == nil {
		m.template_from = make(map[int]struct{})
	}
	for i := range ids {
		m.template_from[ids[i]] = struct{}{}
	}
}

// ClearTemplateFrom clears the template_from edge to Template.
func (m *ServerMutation) ClearTemplateFrom() {
	m.clearedtemplate_from = true
}

// TemplateFromCleared returns if the edge template_from was cleared.
func (m *ServerMutation) TemplateFromCleared() bool {
	return m.clearedtemplate_from
}

// RemoveTemplateFromIDs removes the template_from edge to Template by ids.
func (m *ServerMutation) RemoveTemplateFromIDs(ids ...int) {
	if m.removedtemplate_from == nil {
		m.removedtemplate_from = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtemplate_from[ids[i]] = struct{}{}
	}
}

// RemovedTemplateFrom returns the removed ids of template_from.
func (m *ServerMutation) RemovedTemplateFromIDs() (ids []int) {
	for id := range m.removedtemplate_from {
		ids = append(ids, id)
	}
	return
}

// TemplateFromIDs returns the template_from ids in the mutation.
func (m *ServerMutation) TemplateFromIDs() (ids []int) {
	for id := range m.template_from {
		ids = append(ids, id)
	}
	return
}

// ResetTemplateFrom reset all changes of the "template_from" edge.
func (m *ServerMutation) ResetTemplateFrom() {
	m.template_from = nil
	m.clearedtemplate_from = false
	m.removedtemplate_from = nil
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, server.FieldName)
	}
	if m.template != nil {
		fields = append(fields, server.FieldTemplate)
	}
	if m.variables != nil {
		fields = append(fields, server.FieldVariables)
	}
	if m.ip != nil {
		fields = append(fields, server.FieldIP)
	}
	if m.description != nil {
		fields = append(fields, server.FieldDescription)
	}
	if m.cpu != nil {
		fields = append(fields, server.FieldCPU)
	}
	if m.memory != nil {
		fields = append(fields, server.FieldMemory)
	}
	if m.nvidia_gpu != nil {
		fields = append(fields, server.FieldNvidiaGpu)
	}
	if m.created_at != nil {
		fields = append(fields, server.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, server.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldName:
		return m.Name()
	case server.FieldTemplate:
		return m.Template()
	case server.FieldVariables:
		return m.Variables()
	case server.FieldIP:
		return m.IP()
	case server.FieldDescription:
		return m.Description()
	case server.FieldCPU:
		return m.CPU()
	case server.FieldMemory:
		return m.Memory()
	case server.FieldNvidiaGpu:
		return m.NvidiaGpu()
	case server.FieldCreatedAt:
		return m.CreatedAt()
	case server.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldName:
		return m.OldName(ctx)
	case server.FieldTemplate:
		return m.OldTemplate(ctx)
	case server.FieldVariables:
		return m.OldVariables(ctx)
	case server.FieldIP:
		return m.OldIP(ctx)
	case server.FieldDescription:
		return m.OldDescription(ctx)
	case server.FieldCPU:
		return m.OldCPU(ctx)
	case server.FieldMemory:
		return m.OldMemory(ctx)
	case server.FieldNvidiaGpu:
		return m.OldNvidiaGpu(ctx)
	case server.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case server.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case server.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case server.FieldVariables:
		v, ok := value.(*common.TemplateVariables)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case server.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case server.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case server.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case server.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case server.FieldNvidiaGpu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNvidiaGpu(v)
		return nil
	case server.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case server.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServerMutation) AddedFields() []string {
	var fields []string
	if m.addcpu != nil {
		fields = append(fields, server.FieldCPU)
	}
	if m.addmemory != nil {
		fields = append(fields, server.FieldMemory)
	}
	if m.addnvidia_gpu != nil {
		fields = append(fields, server.FieldNvidiaGpu)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCPU:
		return m.AddedCPU()
	case server.FieldMemory:
		return m.AddedMemory()
	case server.FieldNvidiaGpu:
		return m.AddedNvidiaGpu()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case server.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPU(v)
		return nil
	case server.FieldMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case server.FieldNvidiaGpu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNvidiaGpu(v)
		return nil
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldDeletedAt) {
		fields = append(fields, server.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldName:
		m.ResetName()
		return nil
	case server.FieldTemplate:
		m.ResetTemplate()
		return nil
	case server.FieldVariables:
		m.ResetVariables()
		return nil
	case server.FieldIP:
		m.ResetIP()
		return nil
	case server.FieldDescription:
		m.ResetDescription()
		return nil
	case server.FieldCPU:
		m.ResetCPU()
		return nil
	case server.FieldMemory:
		m.ResetMemory()
		return nil
	case server.FieldNvidiaGpu:
		m.ResetNvidiaGpu()
		return nil
	case server.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case server.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owners != nil {
		edges = append(edges, server.EdgeOwners)
	}
	if m.event != nil {
		edges = append(edges, server.EdgeEvent)
	}
	if m.template_from != nil {
		edges = append(edges, server.EdgeTemplateFrom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.owners))
		for id := range m.owners {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeTemplateFrom:
		ids := make([]ent.Value, 0, len(m.template_from))
		for id := range m.template_from {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedowners != nil {
		edges = append(edges, server.EdgeOwners)
	}
	if m.removedevent != nil {
		edges = append(edges, server.EdgeEvent)
	}
	if m.removedtemplate_from != nil {
		edges = append(edges, server.EdgeTemplateFrom)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.removedowners))
		for id := range m.removedowners {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	case server.EdgeTemplateFrom:
		ids := make([]ent.Value, 0, len(m.removedtemplate_from))
		for id := range m.removedtemplate_from {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowners {
		edges = append(edges, server.EdgeOwners)
	}
	if m.clearedevent {
		edges = append(edges, server.EdgeEvent)
	}
	if m.clearedtemplate_from {
		edges = append(edges, server.EdgeTemplateFrom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeOwners:
		return m.clearedowners
	case server.EdgeEvent:
		return m.clearedevent
	case server.EdgeTemplateFrom:
		return m.clearedtemplate_from
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeOwners:
		m.ResetOwners()
		return nil
	case server.EdgeEvent:
		m.ResetEvent()
		return nil
	case server.EdgeTemplateFrom:
		m.ResetTemplateFrom()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// TemplateMutation represents an operation that mutate the Templates
// nodes in the graph.
type TemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	template      *string
	variables     **common.TemplateVariables
	created_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	server        map[int]struct{}
	removedserver map[int]struct{}
	clearedserver bool
	done          bool
	oldValue      func(context.Context) (*Template, error)
	predicates    []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows to manage the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for Template.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the id field of the mutation.
func withTemplateID(id int) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetTemplate sets the template field.
func (m *TemplateMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the template value in the mutation.
func (m *TemplateMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old template value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate reset all changes of the "template" field.
func (m *TemplateMutation) ResetTemplate() {
	m.template = nil
}

// SetVariables sets the variables field.
func (m *TemplateMutation) SetVariables(cv *common.TemplateVariables) {
	m.variables = &cv
}

// Variables returns the variables value in the mutation.
func (m *TemplateMutation) Variables() (r *common.TemplateVariables, exists bool) {
	v := m.variables
	if v == nil {
		return
	}
	return *v, true
}

// OldVariables returns the old variables value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldVariables(ctx context.Context) (v *common.TemplateVariables, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVariables is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVariables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariables: %w", err)
	}
	return oldValue.Variables, nil
}

// ResetVariables reset all changes of the "variables" field.
func (m *TemplateMutation) ResetVariables() {
	m.variables = nil
}

// SetCreatedAt sets the created_at field.
func (m *TemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *TemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *TemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *TemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the Template.
// If the Template object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *TemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[template.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *TemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *TemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, template.FieldDeletedAt)
}

// AddUserIDs adds the user edge to User by ids.
func (m *TemplateMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *TemplateMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *TemplateMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *TemplateMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *TemplateMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *TemplateMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *TemplateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddServerIDs adds the server edge to Server by ids.
func (m *TemplateMutation) AddServerIDs(ids ...int) {
	if m.server == nil {
		m.server = make(map[int]struct{})
	}
	for i := range ids {
		m.server[ids[i]] = struct{}{}
	}
}

// ClearServer clears the server edge to Server.
func (m *TemplateMutation) ClearServer() {
	m.clearedserver = true
}

// ServerCleared returns if the edge server was cleared.
func (m *TemplateMutation) ServerCleared() bool {
	return m.clearedserver
}

// RemoveServerIDs removes the server edge to Server by ids.
func (m *TemplateMutation) RemoveServerIDs(ids ...int) {
	if m.removedserver == nil {
		m.removedserver = make(map[int]struct{})
	}
	for i := range ids {
		m.removedserver[ids[i]] = struct{}{}
	}
}

// RemovedServer returns the removed ids of server.
func (m *TemplateMutation) RemovedServerIDs() (ids []int) {
	for id := range m.removedserver {
		ids = append(ids, id)
	}
	return
}

// ServerIDs returns the server ids in the mutation.
func (m *TemplateMutation) ServerIDs() (ids []int) {
	for id := range m.server {
		ids = append(ids, id)
	}
	return
}

// ResetServer reset all changes of the "server" edge.
func (m *TemplateMutation) ResetServer() {
	m.server = nil
	m.clearedserver = false
	m.removedserver = nil
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.template != nil {
		fields = append(fields, template.FieldTemplate)
	}
	if m.variables != nil {
		fields = append(fields, template.FieldVariables)
	}
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, template.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDescription:
		return m.Description()
	case template.FieldTemplate:
		return m.Template()
	case template.FieldVariables:
		return m.Variables()
	case template.FieldCreatedAt:
		return m.CreatedAt()
	case template.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldTemplate:
		return m.OldTemplate(ctx)
	case template.FieldVariables:
		return m.OldVariables(ctx)
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case template.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case template.FieldVariables:
		v, ok := value.(*common.TemplateVariables)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariables(v)
		return nil
	case template.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case template.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldDeletedAt) {
		fields = append(fields, template.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldTemplate:
		m.ResetTemplate()
		return nil
	case template.FieldVariables:
		m.ResetVariables()
		return nil
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case template.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, template.EdgeUser)
	}
	if m.server != nil {
		edges = append(edges, template.EdgeServer)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeServer:
		ids := make([]ent.Value, 0, len(m.server))
		for id := range m.server {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, template.EdgeUser)
	}
	if m.removedserver != nil {
		edges = append(edges, template.EdgeServer)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeServer:
		ids := make([]ent.Value, 0, len(m.removedserver))
		for id := range m.removedserver {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, template.EdgeUser)
	}
	if m.clearedserver {
		edges = append(edges, template.EdgeServer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeUser:
		return m.cleareduser
	case template.EdgeServer:
		return m.clearedserver
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeUser:
		m.ResetUser()
		return nil
	case template.EdgeServer:
		m.ResetServer()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	user_id             *string
	user_pw             *string
	quota_instance      *int
	addquota_instance   *int
	quota_cpu           *int
	addquota_cpu        *int
	quota_memory        *int
	addquota_memory     *int
	quota_nvidia_gpu    *int
	addquota_nvidia_gpu *int
	quota_storage       *int
	addquota_storage    *int
	created_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	events              map[int]struct{}
	removedevents       map[int]struct{}
	clearedevents       bool
	servers             map[int]struct{}
	removedservers      map[int]struct{}
	clearedservers      bool
	templates           map[int]struct{}
	removedtemplates    map[int]struct{}
	clearedtemplates    bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for User.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user_id field.
func (m *UserMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the user_id value in the mutation.
func (m *UserMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID reset all changes of the "user_id" field.
func (m *UserMutation) ResetUserID() {
	m.user_id = nil
}

// SetUserPw sets the user_pw field.
func (m *UserMutation) SetUserPw(s string) {
	m.user_pw = &s
}

// UserPw returns the user_pw value in the mutation.
func (m *UserMutation) UserPw() (r string, exists bool) {
	v := m.user_pw
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPw returns the old user_pw value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUserPw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserPw is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserPw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPw: %w", err)
	}
	return oldValue.UserPw, nil
}

// ResetUserPw reset all changes of the "user_pw" field.
func (m *UserMutation) ResetUserPw() {
	m.user_pw = nil
}

// SetQuotaInstance sets the quota_instance field.
func (m *UserMutation) SetQuotaInstance(i int) {
	m.quota_instance = &i
	m.addquota_instance = nil
}

// QuotaInstance returns the quota_instance value in the mutation.
func (m *UserMutation) QuotaInstance() (r int, exists bool) {
	v := m.quota_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaInstance returns the old quota_instance value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldQuotaInstance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuotaInstance is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuotaInstance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaInstance: %w", err)
	}
	return oldValue.QuotaInstance, nil
}

// AddQuotaInstance adds i to quota_instance.
func (m *UserMutation) AddQuotaInstance(i int) {
	if m.addquota_instance != nil {
		*m.addquota_instance += i
	} else {
		m.addquota_instance = &i
	}
}

// AddedQuotaInstance returns the value that was added to the quota_instance field in this mutation.
func (m *UserMutation) AddedQuotaInstance() (r int, exists bool) {
	v := m.addquota_instance
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaInstance reset all changes of the "quota_instance" field.
func (m *UserMutation) ResetQuotaInstance() {
	m.quota_instance = nil
	m.addquota_instance = nil
}

// SetQuotaCPU sets the quota_cpu field.
func (m *UserMutation) SetQuotaCPU(i int) {
	m.quota_cpu = &i
	m.addquota_cpu = nil
}

// QuotaCPU returns the quota_cpu value in the mutation.
func (m *UserMutation) QuotaCPU() (r int, exists bool) {
	v := m.quota_cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaCPU returns the old quota_cpu value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldQuotaCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuotaCPU is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuotaCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaCPU: %w", err)
	}
	return oldValue.QuotaCPU, nil
}

// AddQuotaCPU adds i to quota_cpu.
func (m *UserMutation) AddQuotaCPU(i int) {
	if m.addquota_cpu != nil {
		*m.addquota_cpu += i
	} else {
		m.addquota_cpu = &i
	}
}

// AddedQuotaCPU returns the value that was added to the quota_cpu field in this mutation.
func (m *UserMutation) AddedQuotaCPU() (r int, exists bool) {
	v := m.addquota_cpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaCPU reset all changes of the "quota_cpu" field.
func (m *UserMutation) ResetQuotaCPU() {
	m.quota_cpu = nil
	m.addquota_cpu = nil
}

// SetQuotaMemory sets the quota_memory field.
func (m *UserMutation) SetQuotaMemory(i int) {
	m.quota_memory = &i
	m.addquota_memory = nil
}

// QuotaMemory returns the quota_memory value in the mutation.
func (m *UserMutation) QuotaMemory() (r int, exists bool) {
	v := m.quota_memory
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaMemory returns the old quota_memory value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldQuotaMemory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuotaMemory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuotaMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaMemory: %w", err)
	}
	return oldValue.QuotaMemory, nil
}

// AddQuotaMemory adds i to quota_memory.
func (m *UserMutation) AddQuotaMemory(i int) {
	if m.addquota_memory != nil {
		*m.addquota_memory += i
	} else {
		m.addquota_memory = &i
	}
}

// AddedQuotaMemory returns the value that was added to the quota_memory field in this mutation.
func (m *UserMutation) AddedQuotaMemory() (r int, exists bool) {
	v := m.addquota_memory
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaMemory reset all changes of the "quota_memory" field.
func (m *UserMutation) ResetQuotaMemory() {
	m.quota_memory = nil
	m.addquota_memory = nil
}

// SetQuotaNvidiaGpu sets the quota_nvidia_gpu field.
func (m *UserMutation) SetQuotaNvidiaGpu(i int) {
	m.quota_nvidia_gpu = &i
	m.addquota_nvidia_gpu = nil
}

// QuotaNvidiaGpu returns the quota_nvidia_gpu value in the mutation.
func (m *UserMutation) QuotaNvidiaGpu() (r int, exists bool) {
	v := m.quota_nvidia_gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaNvidiaGpu returns the old quota_nvidia_gpu value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldQuotaNvidiaGpu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuotaNvidiaGpu is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuotaNvidiaGpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaNvidiaGpu: %w", err)
	}
	return oldValue.QuotaNvidiaGpu, nil
}

// AddQuotaNvidiaGpu adds i to quota_nvidia_gpu.
func (m *UserMutation) AddQuotaNvidiaGpu(i int) {
	if m.addquota_nvidia_gpu != nil {
		*m.addquota_nvidia_gpu += i
	} else {
		m.addquota_nvidia_gpu = &i
	}
}

// AddedQuotaNvidiaGpu returns the value that was added to the quota_nvidia_gpu field in this mutation.
func (m *UserMutation) AddedQuotaNvidiaGpu() (r int, exists bool) {
	v := m.addquota_nvidia_gpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaNvidiaGpu reset all changes of the "quota_nvidia_gpu" field.
func (m *UserMutation) ResetQuotaNvidiaGpu() {
	m.quota_nvidia_gpu = nil
	m.addquota_nvidia_gpu = nil
}

// SetQuotaStorage sets the quota_storage field.
func (m *UserMutation) SetQuotaStorage(i int) {
	m.quota_storage = &i
	m.addquota_storage = nil
}

// QuotaStorage returns the quota_storage value in the mutation.
func (m *UserMutation) QuotaStorage() (r int, exists bool) {
	v := m.quota_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaStorage returns the old quota_storage value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldQuotaStorage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuotaStorage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuotaStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaStorage: %w", err)
	}
	return oldValue.QuotaStorage, nil
}

// AddQuotaStorage adds i to quota_storage.
func (m *UserMutation) AddQuotaStorage(i int) {
	if m.addquota_storage != nil {
		*m.addquota_storage += i
	} else {
		m.addquota_storage = &i
	}
}

// AddedQuotaStorage returns the value that was added to the quota_storage field in this mutation.
func (m *UserMutation) AddedQuotaStorage() (r int, exists bool) {
	v := m.addquota_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaStorage reset all changes of the "quota_storage" field.
func (m *UserMutation) ResetQuotaStorage() {
	m.quota_storage = nil
	m.addquota_storage = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddEventIDs adds the events edge to Event by ids.
func (m *UserMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the events edge to Event.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared returns if the edge events was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the events edge to Event by ids.
func (m *UserMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed ids of events.
func (m *UserMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the events ids in the mutation.
func (m *UserMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents reset all changes of the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddServerIDs adds the servers edge to Server by ids.
func (m *UserMutation) AddServerIDs(ids ...int) {
	if m.servers == nil {
		m.servers = make(map[int]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the servers edge to Server.
func (m *UserMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared returns if the edge servers was cleared.
func (m *UserMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the servers edge to Server by ids.
func (m *UserMutation) RemoveServerIDs(ids ...int) {
	if m.removedservers == nil {
		m.removedservers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed ids of servers.
func (m *UserMutation) RemovedServersIDs() (ids []int) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the servers ids in the mutation.
func (m *UserMutation) ServersIDs() (ids []int) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers reset all changes of the "servers" edge.
func (m *UserMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// AddTemplateIDs adds the templates edge to Template by ids.
func (m *UserMutation) AddTemplateIDs(ids ...int) {
	if m.templates == nil {
		m.templates = make(map[int]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the templates edge to Template.
func (m *UserMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared returns if the edge templates was cleared.
func (m *UserMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the templates edge to Template by ids.
func (m *UserMutation) RemoveTemplateIDs(ids ...int) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed ids of templates.
func (m *UserMutation) RemovedTemplatesIDs() (ids []int) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the templates ids in the mutation.
func (m *UserMutation) TemplatesIDs() (ids []int) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates reset all changes of the "templates" edge.
func (m *UserMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_id != nil {
		fields = append(fields, user.FieldUserID)
	}
	if m.user_pw != nil {
		fields = append(fields, user.FieldUserPw)
	}
	if m.quota_instance != nil {
		fields = append(fields, user.FieldQuotaInstance)
	}
	if m.quota_cpu != nil {
		fields = append(fields, user.FieldQuotaCPU)
	}
	if m.quota_memory != nil {
		fields = append(fields, user.FieldQuotaMemory)
	}
	if m.quota_nvidia_gpu != nil {
		fields = append(fields, user.FieldQuotaNvidiaGpu)
	}
	if m.quota_storage != nil {
		fields = append(fields, user.FieldQuotaStorage)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserID:
		return m.UserID()
	case user.FieldUserPw:
		return m.UserPw()
	case user.FieldQuotaInstance:
		return m.QuotaInstance()
	case user.FieldQuotaCPU:
		return m.QuotaCPU()
	case user.FieldQuotaMemory:
		return m.QuotaMemory()
	case user.FieldQuotaNvidiaGpu:
		return m.QuotaNvidiaGpu()
	case user.FieldQuotaStorage:
		return m.QuotaStorage()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserID:
		return m.OldUserID(ctx)
	case user.FieldUserPw:
		return m.OldUserPw(ctx)
	case user.FieldQuotaInstance:
		return m.OldQuotaInstance(ctx)
	case user.FieldQuotaCPU:
		return m.OldQuotaCPU(ctx)
	case user.FieldQuotaMemory:
		return m.OldQuotaMemory(ctx)
	case user.FieldQuotaNvidiaGpu:
		return m.OldQuotaNvidiaGpu(ctx)
	case user.FieldQuotaStorage:
		return m.OldQuotaStorage(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case user.FieldUserPw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPw(v)
		return nil
	case user.FieldQuotaInstance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaInstance(v)
		return nil
	case user.FieldQuotaCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaCPU(v)
		return nil
	case user.FieldQuotaMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaMemory(v)
		return nil
	case user.FieldQuotaNvidiaGpu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaNvidiaGpu(v)
		return nil
	case user.FieldQuotaStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaStorage(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addquota_instance != nil {
		fields = append(fields, user.FieldQuotaInstance)
	}
	if m.addquota_cpu != nil {
		fields = append(fields, user.FieldQuotaCPU)
	}
	if m.addquota_memory != nil {
		fields = append(fields, user.FieldQuotaMemory)
	}
	if m.addquota_nvidia_gpu != nil {
		fields = append(fields, user.FieldQuotaNvidiaGpu)
	}
	if m.addquota_storage != nil {
		fields = append(fields, user.FieldQuotaStorage)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldQuotaInstance:
		return m.AddedQuotaInstance()
	case user.FieldQuotaCPU:
		return m.AddedQuotaCPU()
	case user.FieldQuotaMemory:
		return m.AddedQuotaMemory()
	case user.FieldQuotaNvidiaGpu:
		return m.AddedQuotaNvidiaGpu()
	case user.FieldQuotaStorage:
		return m.AddedQuotaStorage()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldQuotaInstance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaInstance(v)
		return nil
	case user.FieldQuotaCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaCPU(v)
		return nil
	case user.FieldQuotaMemory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaMemory(v)
		return nil
	case user.FieldQuotaNvidiaGpu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaNvidiaGpu(v)
		return nil
	case user.FieldQuotaStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaStorage(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserID:
		m.ResetUserID()
		return nil
	case user.FieldUserPw:
		m.ResetUserPw()
		return nil
	case user.FieldQuotaInstance:
		m.ResetQuotaInstance()
		return nil
	case user.FieldQuotaCPU:
		m.ResetQuotaCPU()
		return nil
	case user.FieldQuotaMemory:
		m.ResetQuotaMemory()
		return nil
	case user.FieldQuotaNvidiaGpu:
		m.ResetQuotaNvidiaGpu()
		return nil
	case user.FieldQuotaStorage:
		m.ResetQuotaStorage()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.servers != nil {
		edges = append(edges, user.EdgeServers)
	}
	if m.templates != nil {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.removedservers != nil {
		edges = append(edges, user.EdgeServers)
	}
	if m.removedtemplates != nil {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	if m.clearedservers {
		edges = append(edges, user.EdgeServers)
	}
	if m.clearedtemplates {
		edges = append(edges, user.EdgeTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEvents:
		return m.clearedevents
	case user.EdgeServers:
		return m.clearedservers
	case user.EdgeTemplates:
		return m.clearedtemplates
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	case user.EdgeServers:
		m.ResetServers()
		return nil
	case user.EdgeTemplates:
		m.ResetTemplates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
